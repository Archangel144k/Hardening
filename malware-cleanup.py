#!/usr/bin/env python3
"""
UNIVERSAL LINUX MALWARE CLEANUP TOOL - ERROR-CHECKED VERSION
Supports: Debian/Ubuntu, RHEL/CentOS, Fedora, openSUSE, Arch Linux, Alpine
Enhanced error handling and compatibility
"""

import os
import re
import subprocess
import sys
import shutil
import time
import platform
import argparse
import glob
import shlex
from collections import defaultdict

# =============================
# GLOBAL CONFIGURATION (SAFE DEFAULTS)
# =============================
SUSPICIOUS_PORTS = [4444, 8080, 9999, 1337, 31337, 4782]
MAL_IP_RANGES = [
    "192.168.", "10.0.", "172.16.", "172.17.", "172.18.", "172.19.",
    "172.20.", "172.21.", "172.22.", "172.23.", "172.24.", "172.25."
]

# Process patterns (case-insensitive)
MAL_PROCESS_PATTERNS = [
    r"meterpreter", r"reverse_(tcp|http|https)", r"shell\.elf", 
    r"payload\.exe", r"\.bin", r"cryptominer", r"minerd",
    r"xmr-stak", r"xmrig", r"kinsing", r"libsystem", r"\.tmp"
]

# File scanning directories
SCAN_DIRS = [
    "/tmp", "/dev/shm", "/var/tmp", "/run/user", 
    "/root/", "/home/*", "/etc/cron*", "/var/spool/cron",
    "/usr/local/bin", "/usr/bin", "/usr/sbin", "/bin", "/sbin",
    "/lib", "/lib64", "/etc/systemd/system", "/lib/systemd/system"
]

# Malware artifacts
MAL_ARTIFACTS = [
    "/.ssh/authorized_keys", "/.ssh/known_hosts",
    "/etc/crontab", "/etc/rc.local", "/etc/init.d",
    "/root/.msf4", "/root/.wget-hsts", "/root/.cache"
]

# Distribution configurations
DISTRO_CONFIG = {
    "debian": {"pkg_manager": "apt", "netstat_cmd": "netstat -tupan"},
    "ubuntu": {"pkg_manager": "apt", "netstat_cmd": "netstat -tupan"},
    "centos": {"pkg_manager": "yum", "netstat_cmd": "ss -tupan"},
    "rhel": {"pkg_manager": "yum", "netstat_cmd": "ss -tupan"},
    "fedora": {"pkg_manager": "dnf", "netstat_cmd": "ss -tupan"},
    "opensuse": {"pkg_manager": "zypper", "netstat_cmd": "ss -tupan"},
    "arch": {"pkg_manager": "pacman", "netstat_cmd": "ss -tupan"},
    "alpine": {"pkg_manager": "apk", "netstat_cmd": "netstat -tupan"}
}

# =============================
# ERROR-RESISTANT UTILITIES
# =============================
def safe_glob(pattern):
    """Handle glob patterns safely with error catching"""
    try:
        return glob.glob(pattern)
    except Exception as e:
        print(f"  [WARNING] Glob error on {pattern}: {str(e)}")
        return []

def run_cmd(cmd):
    """Execute shell command safely with comprehensive error handling"""
    if not cmd:
        return ""
    
    try:
        result = subprocess.check_output(
            cmd, 
            shell=True, 
            stderr=subprocess.STDOUT, 
            text=True,
            timeout=30,
            executable="/bin/bash"
        )
        return result.strip()
    except subprocess.CalledProcessError as e:
        return e.output.strip()
    except subprocess.TimeoutExpired:
        print(f"  [TIMEOUT] Command exceeded 30s: {cmd}")
        return ""
    except Exception as e:
        print(f"  [ERROR] Command execution failed: {cmd}\n    {str(e)}")
        return ""

def is_valid_ip(ip):
    """Validate IP address format"""
    return re.match(r"^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$", ip) is not None

# =============================
# SYSTEM DETECTION (WITH ERROR HANDLING)
# =============================
def detect_distro():
    """Identify Linux distribution safely"""
    try:
        # Try modern os-release first
        if os.path.exists("/etc/os-release"):
            with open("/etc/os-release", "r") as f:
                content = f.read()
            if match := re.search(r'^ID=["]?([^"\n]*)', content, re.MULTILINE):
                return match.group(1).lower().strip('"'), ""
        
        # Fallback to legacy files
        for release_file in ["/etc/redhat-release", "/etc/lsb-release", "/etc/debian_version"]:
            if os.path.exists(release_file):
                return platform.system().lower(), ""
                
        # Final fallback
        return platform.system().lower(), ""
    except Exception as e:
        print(f"  [ERROR] Distro detection failed: {str(e)}")
        return "unknown", ""

# =============================
# DETECTION FUNCTIONS (ERROR-PROOF)
# =============================
def detect_malicious_connections(distro_id):
    """Find suspicious network connections safely"""
    print("\n[+] Scanning network connections...")
    malicious_conns = []
    netstat_cmd = DISTRO_CONFIG.get(distro_id, {}).get("netstat_cmd", "netstat -tupan")
    
    try:
        connections = run_cmd(f"{netstat_cmd} 2>/dev/null")
        if not connections:
            print("  [WARNING] No network connections data found")
            return []
            
        for conn in connections.splitlines():
            # Skip irrelevant lines
            if not conn or "ESTABLISHED" not in conn or "LISTEN" not in conn:
                continue
                
            # Port-based detection
            if any(f":{port}" in conn for port in SUSPICIOUS_PORTS):
                malicious_conns.append(conn)
                print(f"  ! SUSPICIOUS PORT: {conn[:100]}")
                continue
                
            # IP range detection
            if any(ip_range in conn for ip_range in MAL_IP_RANGES):
                malicious_conns.append(conn)
                print(f"  ! INTERNAL NETWORK CONN: {conn[:100]}")
    except Exception as e:
        print(f"  [ERROR] Connection scan failed: {str(e)}")
        
    return malicious_conns

def detect_malicious_processes():
    """Find suspicious processes safely"""
    print("\n[+] Scanning processes...")
    malicious_procs = []
    
    try:
        # Cross-platform process listing
        ps_cmd = "ps aux 2>/dev/null || ps -ef 2>/dev/null"
        ps_output = run_cmd(ps_cmd)
        if not ps_output:
            print("  [WARNING] No process data found")
            return []
            
        for proc in ps_output.splitlines():
            # Skip headers
            if "PID" in proc and "COMMAND" in proc:
                continue
                
            proc_lower = proc.lower()
            if any(re.search(pattern, proc_lower) for pattern in MAL_PROCESS_PATTERNS):
                malicious_procs.append(proc)
                print(f"  ! MALICIOUS PROCESS: {proc[:100]}...")
    except Exception as e:
        print(f"  [ERROR] Process scan failed: {str(e)}")
        
    return malicious_procs

def detect_malicious_files():
    """Scan for suspicious files safely"""
    print("\n[+] Scanning filesystem...")
    found_files = []
    
    try:
        # Scan directories safely
        for pattern in SCAN_DIRS:
            for dir_path in safe_glob(pattern):
                if not os.path.exists(dir_path):
                    continue
                    
                print(f"  Scanning {dir_path}...")
                try:
                    # Safe file discovery
                    find_cmd = f"find '{dir_path}' -type f 2>/dev/null"
                    files = run_cmd(find_cmd).splitlines()
                    
                    for file_path in files:
                        if not file_path or not os.path.exists(file_path):
                            continue
                            
                        # Skip safe directories
                        if any(d in file_path for d in ["/usr/share/", "/snap/", "/var/lib/"]):
                            continue
                            
                        # Size checks
                        try:
                            if ("/tmp/" in file_path or "/shm/" in file_path) and os.path.getsize(file_path) > 10485760:
                                found_files.append(file_path)
                                print(f"    ! LARGE TEMP FILE: {file_path}")
                        except:
                            pass
                            
                        # Executable checks
                        try:
                            if os.access(file_path, os.X_OK):
                                found_files.append(file_path)
                                print(f"    ! EXECUTABLE: {file_path}")
                        except:
                            pass
                except Exception as e:
                    print(f"    [ERROR] File scan failed: {str(e)}")
                    
        # Check artifacts
        for pattern in MAL_ARTIFACTS:
            for artifact in safe_glob(pattern):
                if os.path.exists(artifact):
                    found_files.append(artifact)
                    print(f"    ! ARTIFACT: {artifact}")
    except Exception as e:
        print(f"  [ERROR] Filesystem scan failed: {str(e)}")
        
    return found_files

def detect_persistence(distro_id):
    """Check for persistence mechanisms safely"""
    print("\n[+] Scanning persistence mechanisms...")
    persistence_items = []
    
    try:
        # Cron jobs
        cron_jobs = run_cmd("crontab -l 2>/dev/null")
        cron_jobs += run_cmd("cat /etc/crontab /etc/cron.*/* 2>/dev/null")
        
        if cron_jobs and ("reverse" in cron_jobs.lower() or "payload" in cron_jobs.lower()):
            print("  ! MALICIOUS CRON DETECTED")
            persistence_items.append(("cron", cron_jobs))
            
        # Systemd services
        services = run_cmd("systemctl list-unit-files --state=enabled 2>/dev/null")
        for service in services.splitlines():
            if "enabled" in service:
                service_name = service.split()[0]
                status = run_cmd(f"systemctl status {service_name} 2>/dev/null")
                if status and ("reverse" in status.lower() or "payload" in status.lower()):
                    print(f"  ! SUSPICIOUS SERVICE: {service_name}")
                    persistence_items.append(("service", service_name))
    except Exception as e:
        print(f"  [ERROR] Persistence scan failed: {str(e)}")
        
    return persistence_items

# =============================
# SAFE REMEDIATION FUNCTIONS
# =============================
def kill_malicious_processes(processes):
    """Terminate processes safely"""
    print("\n[+] Terminating processes...")
    killed = set()
    
    for proc in processes:
        try:
            pid = re.search(r"\b(\d{3,6})\b", proc)
            if pid and pid.group(1) not in killed:
                pid = pid.group(1)
                print(f"  Killing PID: {pid}")
                run_cmd(f"kill -9 {pid}")
                killed.add(pid)
        except Exception as e:
            print(f"    [ERROR] Kill failed: {str(e)}")

def block_malicious_connections(connections):
    """Block IPs safely"""
    print("\n[+] Blocking malicious IPs...")
    blocked = set()
    
    for conn in connections:
        try:
            ip_match = re.search(r"(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})", conn)
            if ip_match:
                ip = ip_match.group(1)
                if ip not in blocked and is_valid_ip(ip):
                    print(f"  Blocking IP: {ip}")
                    run_cmd(f"iptables -A INPUT -s {ip} -j DROP 2>/dev/null")
                    run_cmd(f"ip6tables -A INPUT -s {ip} -j DROP 2>/dev/null")
                    blocked.add(ip)
        except Exception as e:
            print(f"    [ERROR] Block failed: {str(e)}")

def remove_malicious_files(files):
    """Delete files safely"""
    print("\n[+] Removing malicious files...")
    
    for file_path in set(files):  # Deduplicate
        try:
            if os.path.exists(file_path):
                print(f"  Removing: {file_path}")
                if os.path.isdir(file_path):
                    shutil.rmtree(file_path, ignore_errors=True)
                else:
                    os.remove(file_path)
        except Exception as e:
            print(f"    [ERROR] Removal failed: {str(e)}")

def remove_persistence(items, distro_id):
    """Remove persistence safely"""
    print("\n[+] Removing persistence...")
    
    for item_type, item in items:
        try:
            if item_type == "cron":
                print("  Resetting crontab...")
                run_cmd("crontab -r 2>/dev/null")
                run_cmd("rm -f /etc/cron*/*malware*")
            elif item_type == "service":
                print(f"  Removing service: {item}")
                run_cmd(f"systemctl stop {item} 2>/dev/null")
                run_cmd(f"systemctl disable {item} 2>/dev/null")
                run_cmd(f"rm -f /etc/systemd/system/{item}*")
        except Exception as e:
            print(f"    [ERROR] Persistence removal failed: {str(e)}")

# =============================
# MAIN EXECUTION (SAFEGUARDED)
# =============================
def main():
    # Initial checks
    if os.geteuid() != 0:
        print("ERROR: Must be run as root!")
        sys.exit(1)
        
    # Detect distribution
    distro_id, _ = detect_distro()
    print(f"\n[+] Detected OS: {distro_id or 'Unknown'}")
    
    # Parse arguments
    parser = argparse.ArgumentParser(description="Universal Linux Malware Cleanup Tool")
    parser.add_argument("--scan", action="store_true", help="Scan only mode")
    parser.add_argument("--no-clean", action="store_true", help="Skip cleanup")
    args = parser.parse_args()
    
    # ASCII Banner
    print(r"""
    __  __       _ _   _ _    _       _      _____ _                 _ 
   |  \/  |     | | | (_) |  | |     | |    / ____| |               | |
   | \  / |_   _| | |_ _| |  | | __ _| |   | |    | | ___  _   _  __| |
   | |\/| | | | | | __| | |  | |/ _` | |   | |    | |/ _ \| | | |/ _` |
   | |  | | |_| | | |_| | |__| | (_| | |   | |____| | (_) | |_| | (_| |
   |_|  |_|\__,_|_|\__|_|\____/ \__,_|_|    \_____|_|\___/ \__,_|\__,_|
    """)
    print("[=== UNIVERSAL MALWARE CLEANUP TOOL - SAFE MODE ===]")
    
    # Detection phase
    print("\n[=== PHASE 1: DETECTION ===]")
    connections = detect_malicious_connections(distro_id)
    processes = detect_malicious_processes()
    files = detect_malicious_files()
    persistence = detect_persistence(distro_id)
    
    # Detection summary
    print("\n[=== DETECTION SUMMARY ===]")
    print(f"* Suspicious Connections: {len(connections)}")
    print(f"* Malicious Processes: {len(processes)}")
    print(f"* Suspicious Files: {len(files)}")
    print(f"* Persistence Mechanisms: {len(persistence)}")
    
    if not any([connections, processes, files, persistence]):
        print("\n[+] System clean! No threats detected")
        sys.exit(0)
        
    # Exit if scan-only mode
    if args.scan or args.no_clean:
        print("\n[+] Scan completed. No changes made.")
        sys.exit(0)
        
    # User confirmation
    print("\n[!] WARNING: Cleanup will modify system!")
    confirm = input("    Proceed with cleanup? (y/N): ").strip().lower()
    if confirm != 'y':
        print("[*] Cleanup aborted by user")
        sys.exit(0)
        
    # Remediation phase
    print("\n[=== PHASE 2: REMEDIATION ===]")
    if processes: kill_malicious_processes(processes)
    if connections: block_malicious_connections(connections)
    if files: remove_malicious_files(files)
    if persistence: remove_persistence(persistence, distro_id)
    
    # Verification scan
    print("\n[=== PHASE 3: VERIFICATION ===]")
    remaining = []
    print("\n[*] Rescanning system...")
    time.sleep(2)
    remaining += detect_malicious_connections(distro_id)
    remaining += detect_malicious_processes()
    remaining += detect_malicious_files()
    remaining += detect_persistence(distro_id)
    
    # Final report
    print("\n[=== CLEANUP REPORT ===]")
    print(f"* Items remaining: {len(remaining)}")
    if not remaining:
        print("\n[+] SUCCESS: All detected threats removed!")
    else:
        print("\n[!] WARNING: Some items remain. Manual review required!")
        
    # Security recommendations
    print("\n[+] RECOMMENDED ACTIONS:")
    print(" 1. Reboot system")
    print(" 2. Change all passwords")
    print(" 3. Update system packages")
    print(" 4. Run: chkrootkit && rkhunter --check")
    print(" 5. Monitor system with: journalctl -f")
    
    # Distro-specific update commands
    if distro_id in DISTRO_CONFIG:
        pm = DISTRO_CONFIG[distro_id]["pkg_manager"]
        if pm == "apt": print("\nsudo apt update && sudo apt upgrade -y")
        elif pm == "yum": print("\nsudo yum update -y")
        elif pm == "dnf": print("\nsudo dnf upgrade -y")
        elif pm == "zypper": print("\nsudo zypper ref && sudo zypper update -y")
        elif pm == "pacman": print("\nsudo pacman -Syu --noconfirm")
        elif pm == "apk": print("\nsudo apk update && sudo apk upgrade")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[!] Operation cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n[CRITICAL] Unhandled error: {str(e)}")
        sys.exit(1)